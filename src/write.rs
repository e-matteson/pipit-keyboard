use std::collections::HashMap;
use std::path::Path;
use std::ffi::OsStr;
use time::*;

use options::format::*;
use key_types::*;

const AUTHOR: &str = "rusty-pipit";

type LenMap = HashMap<usize, Vec<String>>;
type SeqMap = HashMap<String, Sequence>;

// pub fn format_options() -> Format{

// }

// pub fn format_lookups(seq_map: &SeqMap) -> Format{
pub fn format_lookups(seq_map: &SeqMap){
    let len_map = make_length_map(seq_map);
    // let chord_arrays: Vec<Chord>
    for length in len_map.keys() {
        let flat_seq = make_flat_sequence(seq_map, &len_map, 3);
        println!("{:?}", flat_seq);
        // seq_arrays[length] = self._raw_seq_bytes(flat_sequence, use_mods=True)
        // ...
    }
}


fn make_flat_sequence(seq_map: &SeqMap, len_map: &LenMap, length: usize)
                      -> Sequence {
    let mut flat_seq = Vec::new();
    for name in &len_map[&length]{
        flat_seq.extend(seq_map[name].clone());
    }
    flat_seq
}

fn make_length_map(seq_map: &HashMap<String, Sequence>) -> LenMap {
    let mut len_map = HashMap::new();
    let mut names: Vec<_> = seq_map.keys().collect();
    names.sort();
    for name in names{
        let length = seq_map[name].len();
        len_map.entry(length).or_insert(Vec::new()).push(name.to_owned());
    }
    len_map
}

pub fn format_intro(h_file_name: &str) -> Format{
    let mut f = Format::new();
    let guard_name = make_guard_name(h_file_name);
    let autogen_message = make_autogen_message();

    f.h += &autogen_message;
    f.h += &format!("#ifndef {}\n#define {}\n\n", guard_name, guard_name);
    f.h += "#include <Arduino.h>\n";
    f.h += "#include \"keycodes.h\"\n\n";
    f.h += "typedef void (*voidFuncPtr)(void);\n\n";

    // TODO clean up debug macros
    f.h += "#if DEBUG_MESSAGES == 0\n#define DEBUG1(msg)\n#define DEBUG1_LN(msg)\n#define DEBUG2(msg)\n#define DEBUG2_LN(msg)\n#endif\n\n";
    f.h += "#if DEBUG_MESSAGES == 1\n#define DEBUG1(msg) Serial.print(msg)\n#define DEBUG1_LN(msg) Serial.println(msg)\n#define DEBUG2(msg)\n#define DEBUG2_LN(msg)\n#endif\n\n";
    f.h += "#if DEBUG_MESSAGES == 2\n#define DEBUG1(msg) Serial.print(msg)\n#define DEBUG1_LN(msg) Serial.println(msg)\n#define DEBUG2(msg) Serial.print(msg)\n#define DEBUG2_LN(msg) Serial.println(msg)\n#endif\n\n ";

    f.c += &autogen_message;
    f.c += &format!("#include \"{}\"\n\n", h_file_name);
    f
}

pub fn format_outro() -> Format{
    Format {
        h: "\n#endif\n".to_string(),
        c: String::new(),
    }
}

fn make_autogen_message( ) -> String {
    let s = format!("/**\n * Automatically generated by {} on:  {}\n",
                    AUTHOR,
                    now().strftime("%c").unwrap()
    );
    s + " * Do not make changes here, they will be overwritten.\n */\n\n"
}

fn make_guard_name(h_file_name: &str) -> String {
    // TODO remove unsafe characters, like the python version
    // TODO is this guaranteed to be the basename already?
    let p = Path::new(h_file_name)
        .file_name()
        .expect("failed to get file name")
        .to_str()
        .unwrap()
        .to_string()
        .to_uppercase()
        .replace(".", "_");
    p + "_"

}
